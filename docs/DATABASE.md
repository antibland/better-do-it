# Database Guide

Single source of truth for Better Do It database operations.

## Quick Start

### Environments

- **Development**: SQLite (`sqlite.db`)
- **Production**: PostgreSQL (via `@vercel/postgres`)
- **Detection**: `process.env.NODE_ENV === "production"`

### Better Auth Migrations

```bash
# Edit config
vi lib/auth-config.ts

# Generate schema from config
npm run auth:generate

# Apply migrations locally
npm run auth:migrate

# Production: runs automatically on build
npm run build
```

**Workflow**: Edit config → Generate → Test locally → Commit → Deploy

## Column Naming

### Current Setup

**PostgreSQL** uses lowercase identifiers (`userid`, `iscompleted`)  
**SQLite** uses camelCase identifiers (`userId`, `isCompleted`)  
**Frontend** always receives camelCase via API transformation layer

### Why They Differ

PostgreSQL lowercases unquoted identifiers. SQLite preserves exact casing. Our tables were created without quotes in PostgreSQL, resulting in lowercase names.

### How It Works

The `db-abstraction.ts` layer automatically maps between database column names and frontend expectations:

```typescript
// Frontend always gets camelCase regardless of DB
const task = await select(["userId", "isCompleted"]).from("task").executeOne();
// → { userId: "...", isCompleted: true }
```

### Better Auth vs App Tables

| Category | Tables                               | Management      | CLI Support |
| -------- | ------------------------------------ | --------------- | ----------- |
| **Auth** | user, session, account, verification | Better Auth CLI | ✅ Yes      |
| **App**  | task, partnership, invite, comment   | `lib/db.ts`     | ❌ No       |

**Why Separate**: Better Auth handles authentication. App tables are business logic and stay in your codebase.

## Commands

### Database Health

```bash
# Production
curl https://better-do-it.com/api/health-check-public | jq

# Local
curl http://localhost:3000/api/test-db | jq
```

### Local Development

```bash
# View schema
sqlite3 sqlite.db ".schema"

# Reset database
rm sqlite.db && npm run dev

# Check data
sqlite3 sqlite.db "SELECT COUNT(*) FROM task WHERE isActive = 1"
```

## Troubleshooting

### Schema Out of Sync

```bash
# Regenerate from Better Auth config
npm run auth:generate

# Apply changes
npm run auth:migrate
```

### Column Not Found Error

1. Check environment detection: `process.env.NODE_ENV === "production"`
2. Verify transformation layer in `db-abstraction.ts`
3. Use abstraction layer methods instead of raw SQL

### Migration Issues

1. Check `lib/auth-config.ts` for recent changes
2. Run `npm run auth:generate` to see what SQL will be generated
3. Test with `npm run auth:migrate` locally
4. Review generated migration files before committing

## File Structure

```
lib/
├── auth-config.ts      # Better Auth configuration (edit this)
├── db-config.ts        # Database connections
├── db.ts               # App table initialization
└── db-abstraction.ts   # Column name transformation layer

migrations/            # Generated by Better Auth CLI (commit these)
```

## Best Practices

### Do

- Use Better Auth CLI for auth tables only
- Keep app table definitions in `lib/db.ts`
- Use `db-abstraction.ts` for all queries
- Test migrations locally before deploying

### Don't

- Mix Better Auth with app table definitions
- Edit CLI-generated migration files manually
- Skip local testing
- Write raw SQL without considering column name differences

## Emergency Procedures

### Rollback Failed Migration

Better Auth migrations are forward-only. To rollback:

1. Revert changes in `lib/auth-config.ts`
2. Generate new migrations: `npm run auth:generate`
3. Apply and redeploy

### Production Database Issues

```bash
# Check health
curl https://better-do-it.com/api/health-check-public

# View logs
# Vercel Dashboard → Functions → Logs
```

## Summary

**Current Architecture**:

- ✅ Better Auth CLI manages auth tables (automated, no drift)
- ✅ App tables managed in `lib/db.ts` (manual, domain logic)
- ✅ Column name transformation handled automatically
- ✅ Frontend receives consistent camelCase from all APIs

This setup separates authentication from business logic and prevents schema drift.
